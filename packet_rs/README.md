# packet-rs

Contains the Rust version of the supporting library for packetc. 

This library provides the following APIs for reading and writing binary data:

```rust
// reading
let data: &[u8] = ...;
let mut reader = Reader::new(data);
// reads aren't bounds checked
// use .remaining() to check there is enough data for X
reader.remaining();     // returns usize
reader.read_uint8();    // returns u8
reader.read_uint16();   // returns u16
reader.read_uint32();   // returns u32
reader.read_int8();     // returns i8
reader.read_int16();    // returns i16
reader.read_int32();    // returns i32
reader.read_float();    // returns f32
let len = ...;
reader.read_slice(len); // returns &[u8]

// writing
let mut writer = Writer::new();
// if the writer doesn't have enough space, it will re-allocate.
// you're encouraged to pre-allocate enough space up-front, or
// even re-use buffers:
// Writer::with_capacity(len)
// Writer::with_buffer(buf)
writer.write_uint8(0);      // takes u8
writer.write_uint16(0);     // takes u16
writer.write_uint32(0);     // takes u32
writer.write_int8(0);       // takes i8
writer.write_int16(0);      // takes i16
writer.write_int32(0);      // takes i32
writer.write_float(0);      // takes f32
let data: [u8; _] = ...;    
writer.write_slice(&data);  // takes &[u8]
let out = writer.finish();  // returns Vec<u8>
```

The API is inconvenient and verbose, because it is not meant for humans to write, but for use in files generated by the schema compiler. 

pub mod gen_ctx;
/* pub mod rust; */
pub mod ts;

use std::fmt::Write;

use fstrings::format_args_f;
use gen_ctx::GenCtx;

use super::*;

const VERSION: Option<&'static str> = option_env!("CARGO_PKG_VERSION");

pub fn generate<Lang>(from: &check::Resolved) -> String
where
    Lang: Language + Default + Common + Declaration + Impl,
{
    let mut gen = Generator::<Lang>::new();
    gen.push_meta();
    gen.push_common();
    gen.push_decls(&from.types, from.export.name);
    gen.push_impl(&from.export);
    gen.finish()
}

#[macro_export]
macro_rules! append {
    ($dst:expr, $($arg:tt)*) => (fstrings::write_f!($dst, $($arg)*).unwrap());

    ($dst:expr, $arg:expr) => (fstrings::write_f!($dst, "{}", $arg).unwrap());
}

#[macro_export]
macro_rules! cat {
    ($ctx:ident +++) => { $ctx.push_indent() };
    ($ctx:ident ---) => { $ctx.pop_indent() };

    ($ctx:ident, $($arg:tt)*) => {{
        let fmt = fstrings::format_f!($($arg)*);
        fstrings::write_f!($ctx.out, "{}{}", $ctx.indentation, fmt).unwrap()
    }};
}

pub trait Language {}

#[derive(Clone, PartialEq, Debug, Default)]
pub struct Generator<L: Language + Default + Common> {
    state: L,
    buffer: String,
}

impl<L: Language + Default + Common + Declaration + Impl> Generator<L> {
    pub fn new() -> Self {
        Generator {
            state: L::default(),
            buffer: String::new(),
        }
    }

    /// Empty line
    pub fn push_line(&mut self) {
        append!(&mut self.buffer, "\n");
    }

    /// Version info
    pub fn push_meta(&mut self) {
        append!(
            &mut self.buffer,
            "// Generated by packetc v{} at {}\n",
            VERSION.unwrap_or("???"),
            chrono::Utc::now().to_rfc2822()
        );
    }
    pub fn push_common(&mut self) { self.state.gen_common(&mut self.buffer); }
    pub fn push_decls<'a>(&mut self, types: &check::TypeMap<'a>, export: &str) {
        self.state.gen_decls(types, export, &mut self.buffer);
    }
    pub fn push_impl(&mut self, export: &check::Export) { self.state.gen_impl(export, &mut self.buffer); }
    pub fn finish(mut self) -> String { std::mem::take(&mut self.buffer) }
}

pub trait Common {
    fn gen_common(&self, out: &mut String);
}

pub trait Impl {
    fn gen_impl(&self, export: &check::Export, out: &mut String);
}

pub trait Declaration {
    fn gen_decls<'a>(&self, types: &check::TypeMap<'a>, export: &str, out: &mut String);
}

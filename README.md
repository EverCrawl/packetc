# packetc

This repository holds a schema->parser compiler for a binary format intended for usage in bandwidth and latency constrained environments (such as real-time games).

See [format.md](format.md) for rationale.

# Usage

Install the compiler

```s
$ cargo install --git https://github.com/EverCrawl/packetc.git
```

Write a schema

```s
$ echo "Test: struct {
    value: uint8
}
export Test" > test.pkt
```

Compile it: `packetc <lang> <input> <output>`

```s
$ packetc rust test.pkt test.rs
```

Which will output:

```rust
// Generated by packetc v0.1.4 at Mon, 1 Jan 1900 00:00:00 +0000
#![allow(dead_code, non_camel_case_types, unused_imports, clippy::field_reassign_with_default)]
use std::convert::TryFrom;
#[derive(Clone, PartialEq, Debug, Default)]
pub struct Test {
    pub value: u8,
}
pub fn read(reader: &mut packet::reader::Reader, output: &mut Test) -> Result<(), packet::Error> {
    output.value = reader.read_uint8()?;
    Ok(())
}
pub fn write(writer: &mut packet::writer::Writer, input: &Test) {
    writer.write_uint8(input.value);
}
```

Add a dependency on `packet-rs` to your project:

```toml
packet = { package = "packet-rs", git = "https://github.com/EverCrawl/packet-rs.git" }
```

Then include the generated file somewhere in your project...

```rust
// main.rs

mod test;

fn main() {
    // receive some bytes, probably from a socket
    let data = &[0];
    // read the data
    let mut reader = packet::Reader::new(data);
    let mut test = test::Test::default();
    test::read(&mut reader, &mut test).unwrap();
}
```

You can see real usage of the compiler in the [EverCrawl](https://github.com/EverCrawl) project.

### TODOs

- TODO: packet-ts 
- TODO: allow specifying max array size
  - use it to shrink array len encoding
- TODO: discriminated unions
  - syntax: `Name: union { Type0 = Discriminant0, ... }`
    - Discriminant is optional
  - TS emit:
    - `type Name = [0, T0] | [1, T1] | ... | [N, TN]`
  - limits:
    - discriminant -> u8
  - implementation:
    - write:
      - write discriminant
      - write value
    - read:
      - read discriminant into var
      - switch (discriminant)
        - case N => read value of union type #N -> store
- TODO: tuples
  - syntax: `Name: (Type, ...)`
    - tuples don't emit any declaration
  - implementation:
    - write:
      - write value 0
      - write value 1
      - ...
      - write value N
    - read:
      - read value 0 into temp 0
      - read value 1 into temp 1
      - ...
      - read value N into temp N
      - store [temp 0, temp 1, ..., temp N]
- TODO: anonymous structs and unions
# packetc

This is the root of the `packetc` workspace.

`packetc` is a command-line utility which accepts a custom .pkt format as input, and outputs a file in one of the supported languages, which allows for efficient binary serialization/deserialization of data.

The format is built primarily for network applications which have tight constraints on bandwidth and latency, such as real-time games. It does not support versioning or any high-level languages features, for that, there are many other libraries, such as [`Protocol Buffers`](https://developers.google.com/protocol-buffers), [`FlatBuffers`](https://google.github.io/flatbuffers/), or [`Cap'n Proto`](https://capnproto.org/).

The format also assumes that you will always want to read the entire packet, which has the following benefits:
* Faster deserialization, due to better cache locality
  * Each element of the packet is read in sequence, which means far fewer cache misses
* Simpler control flow, due to being able to discard malformed packets early
  * You don't need to try and handle malformed packets outside of the place where your application receives them
* Lower packet size, due to the lack of a packet header
  * Because the format does not support random access, it means there is no need to store offsets or pointers to elements in the packet

### Example 

A packet may look like this:
```sh
# This is a comment.
# Enums are actually bitfields, where each variant is assigned its own bit.
# The size of the enum is 8, 16, or 32 bits, where the chosen size is the lowest which fits all variants.
Flag: enum { A, B }
Position: struct { x: float, y: float }
Value: struct { 
  a: uint32, b: int32, c: uint8, d: uint8
}
# Structs are composed of named and strongly typed fields.
ComplexType: struct {
    # Array types are declared with a "[]" suffix.
    # The type of a field may be either one of the built-in types,
    names: string[],
    # a struct,
    positions: Position[],
    # or an enum.
    flag: Flag,
    values: Value[]
}

# An export defines the actual packet type for which serialization/deserialization will be implemented.
export ComplexType
```

A simpler packet may look like:
```sh
// file: simple.pkt
Test: struct {
    a: uint8,
    b: uint8
}
export Test
```
Compiling the packet file into Rust:
```sh
> packetc rust simple.pkt simple.rs
```
Will result in a file which looks like this:
```rust
// file: simple.rs
// Generated by packetc v0.1.0
#![allow(non_camel_case_types, unused_imports, clippy::field_reassign_with_default)]
use std::convert::TryFrom;
pub type uint8 = u8;
pub type uint16 = u16;
pub type uint32 = u32;
pub type int8 = i8;
pub type int16 = i16;
pub type int32 = i32;
pub type float = f32;
pub type string = String;
#[derive(Clone, PartialEq, Debug, Default)]
pub struct Test {
    pub a: uint8,
    pub b: uint8,
}
pub fn read(reader: &mut packet::reader::Reader, output: &mut Test) -> Result<(), packet::Error> {
    output.a = reader.read_uint8()?;
    output.b = reader.read_uint8()?;
    Ok(())
}
pub fn write(writer: &mut packet::writer::Writer, input: &Test) {
    writer.write_uint8(input.a);
    writer.write_uint8(input.b);
}
```
The file above depends on the `packet_rs` library.

Currently, only Rust and TypeScript are supported as targets for the packet format. The compiler is written in a flexible way, so adding support for new languages is not a herculean feat, but it requires some plumbing:
1. Implement the support library (With the same API as `packet_rs` or `packet_ts`)
   * read/write (unsigned) integer + float types
   * read/write strings
   * all in a fallible way, either by throwing exceptions, returning Result, error codes, or similar
2. Implement the codegen for the language

### Notes

This format was built for my game project, which you can see [`here`](https://github.com/jprochazk/underworld-server) (server), and [`here`](https://github.com/jprochazk/underworld-client) (client).